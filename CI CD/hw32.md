Реализация https://gitlab.com/Alrexcom/hw32

### Задача
#### Требования
1. Pipeliene должен состоять из этапов

- **`code-quality`** - запуск линтеров
- **`tests`** - запуск тестов
- **`build`** - сборка и пуш docker image
- **`deploy`** - запуск контейнера на _удаленной_ машине
- **`notify`** - уведомление о начале pipleine и о его завершении (в любой мессенджер)

2. Этап **`code-quality`** должен включать в себя запуск линтеров как для кода приложения так 
и для файлов docker

```
 Использую проверку файла докера и файлов *.js 
 Воспользовался шаблоном .nmp для сокращения кода
```

3. Этап **`tests`** должен состоять из двух jobs:

- первая должна прогонять unit тесты, запускаться _всегда_ и сохранять в артефактах файл с результатами


```js
test:
  stage: tests       
  extends: .npm
  script:
    - npm test  
  artifacts:
    paths:
      - tests-result.json
  rules:
    - when: always

```
Для работы линтера js пришлось добавить конфиг файл `.eslintrc.js`

```js
module.exports = {
    env: {
      browser: true,
      es2021: true,
      node: true,
    },
    extends: "eslint:recommended",
    parserOptions: {
      ecmaVersion: "latest",
      sourceType: "module",
    }      
  };

```
В package.json

```js
{
  "name": "diary-app",
  "version": "1.0.0",
  "description": "Simple diary with nodejs",
  "main": "server.js",
  "scripts": {
    "code-quality": "eslint . --ext .js,.jsx",              #  сюда
    "start": "node server.js",
    "test": "jest --json --outputFile=tests-result.json"    # тест пользуется этим
  },
  "author": "anestesia",
  "license": "MIT",
  "dependencies": {
    "eslint": "^8.0.0",                                    # и сюда
    "body-parser": "^1.20.2",
    "express": "^4.19.2",
    "jest": "^29.7.0",                               # тест пользуется этим
    "supertest": "^6.3.3"    
  }
}
```

- вторая должна запускаться _после_ удачного деплоя и проверять что приложение доступно
	"зашил" в **deploy** - в нём выполняется проверка и запись в артефакт результата - в один файл.
	Можно конечно сделать отдельно, но тогда прийдётся снова подключаться по ssh на хост для проверки контейнера,
	использовать шаблон для уменьшения кода - это всё время. Лучше в одном.
		
	
после деплоя проверка запущенного докера, результат заносится в тот же файл

4. Этап **build** должен собирать и пушить docker image для приложения (registry можно использовать любой, хоть container registry от самого gitlab, хоть docker hub, хоть свой собственный)

```js
build:kaniko:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]   
  script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"$REGISTRY\":{\"username\":\"$REGISTRY_USER\",\"password\":\"$TOKEN32\"}}}" > /kaniko/.docker/config.json
    - /kaniko/executor
      --context "$CI_PROJECT_DIR"
      --dockerfile "$CI_PROJECT_DIR/Dockerfile"
      --destination ${FULL_IMAGE_NAME}
  rules:
    - when: always 
```


5. Этап **deploy** должен запускать новую версию приложения на _удаленной машине_ (стратегию продумайте самостоятельно);
Подключается по ssh ку хосту и запускает контейнер, предварительно скачав из docker hub.
Сюда поместил тест о запуске контейнера - проверка что приложение запущено

```js
deploy:with-test:
  stage: deploy
  services:
    - name: docker:dind 
      alias: docker
  image: docker:27.5  
  before_script:
    - apk update && apk add openssh-client rsync bash
    - eval "$(ssh-agent -s)"
    - mkdir ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_KEY32" | ssh-add -
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config 
  script:
    - |        
        ssh ${SSH_USER}@${HOST} "docker pull ${FULL_IMAGE_NAME} && \
        docker rm -f $APP_NAME || true && \
        docker run -d --name $APP_NAME -p 3000:3000 ${FULL_IMAGE_NAME}
        echo "$(docker inspect -f '{{.State.Status}}' $APP_NAME)"" >> tests-result.json
  artifacts:
      paths:
        - tests-result.json 
  rules:
    - when: always
```
6. Этап **`notify`** должен запускаться дважды:

- при старте пайплайна
```js
notify:start:
  stage: notify
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - |
      curl -s -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage" \
        -d chat_id=${TG_CHAT_ID} \
        -d text="🚀 Pipeline started!
        Project: ${CI_PROJECT_NAME}
        Branch: ${CI_COMMIT_REF_NAME}
        Commit: ${CI_COMMIT_SHORT_SHA}
        Author: ${GITLAB_USER_NAME}
        URL: ${CI_PIPELINE_URL}"
  rules:
    - when: always
```

- по окончанию пайплайна (включая статус завершения)
- _опционально_ в уведомлении об окончании пайплайна можно добавить файл с результатами тестов

```js
notify:end:
  stage: notify-end
  image: alpine:latest
  dependencies:
    - deploy:with-test
  before_script:
    - apk add --no-cache curl
  script:
    - |
      STATUS="✅ SUCCESS"
      if [[ "$CI_PIPELINE_STATUS" == "failed" ]]; then
        STATUS="❌ FAILED"
      elif [[ "$CI_PIPELINE_STATUS" == "canceled" ]]; then
        STATUS="🚫 CANCELED"
      fi

      # Отправка текстового уведомления
      curl -s -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage" \
        -d chat_id=${TG_CHAT_ID} \
        -d text="🏁 Pipeline finished $STATUS
        Project: ${CI_PROJECT_NAME}
        Branch: ${CI_COMMIT_REF_NAME}
        Commit: ${CI_COMMIT_SHORT_SHA}
        Duration: ${CI_PIPELINE_DURATION}s
        URL: ${CI_PIPELINE_URL}"

      # Отправка файла с результатами (если существует)
      if [ -f tests-result.json ]; then
        curl -s -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendDocument" \
          -F chat_id=${TG_CHAT_ID} \
          -F document=@"tests-result.json" \
          -F caption="📄 Test results"
      fi
  rules:
    - when: always
  artifacts:
    paths:
```



## Реализация

.gitlab-ci.yml

```js
stages:
  - notify
  - code-quality 
  - tests
  - build
  - scanning
  - deploy  
  - notify-end


variables:
  APP_NAME: hw32
  TG_CHAT_ID: 421829411
  PRJ_DIR: /opt/hw32
  SSH_USER: gitlab-runner
  HOST: 130.193.41.125
  REGISTRY_USER: alrexcom
  REGISTRY_PATH: hw32
  IMAGE_TAG: $REGISTRY_USER/$REGISTRY_PATH:$CI_COMMIT_SHORT_SHA
  FULL_IMAGE_NAME: ${IMAGE_TAG}_hw32
  REGISTRY: https://index.docker.io/v1/


.npm:
  image: node:20
  before_script:  
    - npm install
  cache:
    paths:
      - node_modules/  


notify:start:
  stage: notify
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - |
      curl -s -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage" \
        -d chat_id=${TG_CHAT_ID} \
        -d text="🚀 Pipeline started!
        Project: ${CI_PROJECT_NAME}
        Branch: ${CI_COMMIT_REF_NAME}
        Commit: ${CI_COMMIT_SHORT_SHA}
        Author: ${GITLAB_USER_NAME}
        URL: ${CI_PIPELINE_URL}"
  rules:
    - when: always


linter:dockerfile:
  stage: code-quality 
  image: hadolint/hadolint:v2.14.0-debian
  script:
    - echo "Checking ... Dockerfile..."
    - hadolint Dockerfile || exit 1
  allow_failure: true
  rules:
    # - if: '$CI_COMMIT_MESSAGE =~ /#full/' 
    - when: always 
   

linter:js_files:
  stage: code-quality
  extends: .npm
  script:
    - echo "Checking ... js files..."
    - npm run code-quality 
  allow_failure: true 
  rules:
    - when: always 
    #- if: '$CI_COMMIT_MESSAGE =~ /#full/'   
 

test:
  stage: tests       
  extends: .npm
  script:
    - npm test  
  artifacts:
    paths:
      - tests-result.json
  rules:
    - when: always


build:kaniko:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]   
  script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"$REGISTRY\":{\"username\":\"$REGISTRY_USER\",\"password\":\"$TOKEN32\"}}}" > /kaniko/.docker/config.json
    - /kaniko/executor
      --context "$CI_PROJECT_DIR"
      --dockerfile "$CI_PROJECT_DIR/Dockerfile"
      --destination ${FULL_IMAGE_NAME}
  rules:
    - when: always 
    #- if: '$CI_COMMIT_MESSAGE =~ /#full/'
 

deploy:with-test:
  stage: deploy
  services:
    - name: docker:dind 
      alias: docker
  image: docker:27.5  
  before_script:
    - apk update && apk add openssh-client rsync bash
    - eval "$(ssh-agent -s)"
    - mkdir ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_KEY32" | ssh-add -
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config 
  script:
    - |        
        ssh ${SSH_USER}@${HOST} "docker pull ${FULL_IMAGE_NAME} && \
        docker rm -f $APP_NAME || true && \
        docker run -d --name $APP_NAME -p 3000:3000 ${FULL_IMAGE_NAME}
        echo "$(docker inspect -f '{{.State.Status}}' $APP_NAME)"" >> tests-result.json
  artifacts:
      paths:
        - tests-result.json 
  rules:
    - when: always



notify:end:
  stage: notify-end
  image: alpine:latest
  dependencies:
    - deploy:with-test
  before_script:
    - apk add --no-cache curl
  script:
    - |
      STATUS="✅ SUCCESS"
      if [[ "$CI_PIPELINE_STATUS" == "failed" ]]; then
        STATUS="❌ FAILED"
      elif [[ "$CI_PIPELINE_STATUS" == "canceled" ]]; then
        STATUS="🚫 CANCELED"
      fi

      # Отправка текстового уведомления
      curl -s -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage" \
        -d chat_id=${TG_CHAT_ID} \
        -d text="🏁 Pipeline finished $STATUS
        Project: ${CI_PROJECT_NAME}
        Branch: ${CI_COMMIT_REF_NAME}
        Commit: ${CI_COMMIT_SHORT_SHA}
        Duration: ${CI_PIPELINE_DURATION}s
        URL: ${CI_PIPELINE_URL}"

      # Отправка файла с результатами (если существует)
      if [ -f tests-result.json ]; then
        curl -s -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendDocument" \
          -F chat_id=${TG_CHAT_ID} \
          -F document=@"tests-result.json" \
          -F caption="📄 Test results"
      fi
  rules:
    - when: always
  artifacts:
    paths:
```
Телеграм
при старте выдаёт сообщение 
```

```